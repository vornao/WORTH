\documentclass{article}

\usepackage[a4paper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm, footnotesep=30pt]{geometry}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}

%New colors defined below
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0.9,0.82}
\definecolor{backcolour}{rgb}{0.95, 0.95, 0.96}

%Code listing style named "mystyle"
\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour},   commentstyle=\color{codegreen},
  keywordstyle=\color{orange},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{magenta},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=4
}

%"mystyle" code listing set
\lstset{style=mystyle}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[italian]{babel}

% Set page size and margins
% Replace `letterpaper' with`a4paper' for UK/EU standard size


% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=false, allcolors=blue]{hyperref}

\title{
    \includegraphics[width=0.4\textwidth]{marchio_unipi_pant541.eps}\\[1cm]
    Relazione Progetto WORTH \\[1ex]
    \large{Corso di Laboratorio di Reti di Calcolatori\\[1ex] A.A 2020/21}\\[1.5cm]
    \noindent \textbf{Studente:} \hfill \textbf{Docente:}\\
    \noindent Luca Miglior - mat. 580671 \hfill Prof.ssa Federica Paganelli
}

\date{}

\begin{document}
\maketitle

\tableofcontents{}
\newpage


\section{Introduzione}
WORTH (WorkTogetHer) è un progetto didattico per la gestione di lavori di gruppo in modo collaborativo, da remoto. Ispirato dalla metodologia \emph{Kanban}, che prevede l'utilizzo di schede mobili (solitamente post-it da affiggere su una lavagna) per indicare i task da eseguire per portare a termine un'attività, il software WORTH si propone di virtualizzare il processo di sviluppo Kanban e rendere accessibili da remoto lavori collaborativi, siano essi professionali, o amatoriali.

WORTH riproduce l'esperienza del lavoro "agile", simulando ogni componente essenziale del \emph{Kanban}: attraverso l'utilizzo della piattaforma, gli utenti potranno registrarsi al servizio e, tramite un'interfaccia grafica o testuale a riga di comando, potranno creare nuovi progetti e collaborare agilmente con altri utenti iscritti al servizio. Sarà possibile creare nuove card per ogni lavagna virtuale, e ogni membro del team potrà riorganizzare le attività, spostando le card da una lista all'altra, o aggiungendo nuovi membri al gruppo di lavoro. WORTH predispone inoltre un sistema di chat per favorire la comunicazione e la condivisione di idee fra i membri di ogni progetto.

L'intero sistema è supportato da un server centrale remoto, che si occuperà di ricevere, gestire e orchestrare la collaborazione fra gli utenti della piattaforma.


\section{Architettura generale del Sistema}
L'architettura generale del sistema è basata sul paradigma Client-Server. Gli utenti del servizio possono accedere al sistema mediante un Client, stateless, che invia le richieste ad un server (in rete locale o Internet) che le elabora e restituisce le informazioni richieste dal client. Le connessioni instaurate fra client e server sono affidate al protocollo TCP/IP. Al momento del lancio di un client, questo instaura una connessione TCP con il server, presso un indirizzo IP e porta noti; inoltre, tramite il paradigma RMI, il client crea un riferimento agli oggetti remoti pubblicati dal server su un registry noto: questi saranno necessari per l'operazione di registrazione al servizio, e verranno invocati su richiesta dell'utente. In seguito alla registrazione, il client potrà quindi effettuare l'operazione di login, unica operazione che permetterà di inviare ulteriori richieste. In seguito al successo dell'operazione di login, il server è pronto a ricevere nuovi messaggi.
\begin{figure}[htbp]
    \includegraphics[width=10cm]{sdGeneral.png}
    \centering
    \caption{\label{fig:sdGeneral}Diagramma di sequenza che mostra l'interazione fra client e server}
\end{figure}
\newpage
I messaggi scambiati fra il client ed il server sono codificati come stringhe in formato JSON\footnote{Per effettuare la serializzazione in stringhe e la deserializzazione in oggetti è stata utilizzata la nota libreria esterna GSON.}.   Ogni messaggio JSON inviato dal client dovrà obbligatoriamente contenere un campo \texttt{login-name} contenente una stringa indicante il nome utente associato al client che ha effettuato la richiesta, e un campo \texttt{method}, contenente una stringa che identifichi univocamente il metodo e il tipo della richiesta che il server dovrà elaborare. Ogni metodo, necessita a sua volta di altri parametri obbligatori, che saranno aggiunti alla stringa JSON della richiesta: ogni parametro necessario al metodo per essere eseguito è identificato da un nome noto, per permettere al server di effettuare il parsing della stringa JSON in oggetti locali, e invocare i metodi correttamente e senza ambiguità. 

Una volta ricevuta una richiesta di un client, il server effettua la deserializzazione della stringa in un generico oggetto JSON\footnote{Con oggetto JSON, si intente un'istanza della classe \texttt{JsonObject} della libreria GSON.}, e procede all'invocazione del metodo richiesto; in seguito all'elaborazione della richiesta viene generata una stringa codificata JSON che contiene il risultato dell'elaborazione. I metodi invocati dal server restituiscono un ulteriore oggetto JSON, che conterrà obbligatoriamente un campo numerico \texttt{return-code}, ad indicare in via preliminare il risultato dell'elaborazione della richiesta. La semantica dei codici di ritorno è la stessa utilizzata dal protocollo HTTP. In caso di successo, l'oggetto JSON conterrà altri campi con i dati prodotti dall'elaborazione della funzione, e il codice restituito avrà un valore del tipo \texttt{2xx}; in caso di fallimento, verrà restituito un codice del tipo \texttt{4xx} oppure \texttt{5xx}, utilizzati rispettivamente in caso di errore riscontrato nella sintassi o nel contenuto della richiesta, oppure in caso di errore interno del server durante l'handling della stessa. L'oggetto risposta JSON è quindi serializzato in una stringa, e inviato sulla connessione TCP al client corrispondente.
Il client, rimasto in ascolto, elaborerà i dati ricevuti dal server, che saranno visualizzati in maniera appropriata all'utente.

La connessione TCP sulla quale viaggiano le richieste è mantenuta aperta, salvo eccezioni, finché non si riceve una richiesta di tipo \texttt{logout} dal client. In seguito alla richiesta di logout il server effettua il logout dell'utente e chiude la connessione; a questo punto anche il client terminerà la connessione invocando il metodo close sul proprio socket TCP. In caso di chiusure inattese della connessione, il server mantiene consistente lo stato del sistema, individuando la connessione che ha causato l'errore ed effettuando le opportune modifiche alle strutture dati locali che identificano il client corrispondente alla socket.

\section{Implementazione del Server}
Il server è il cuore dell'applicazione WORTH: si occupa di gestire le connessioni di rete verso i client e mantiene al suo interno le strutture dati necessarie al soddisfacimento delle richieste; si occupa di salvare in memoria secondaria i dati relativi allo stato della piattaforma, nonché del ripristino delle strutture in seguito a riavvio. Al server è inoltre delegato il compito della gestione e dell'assegnamento degli indirizzi multicast utilizzati dalle chat di progetto.
È stato sviluppato in ambiente UNIX, utilizzando Java 8. È inoltre stata utilizzata la libreria GSON, per la serializzazione in stringhe degli oggetti Java e la deserializzazione, e la libreria Apache Commons CLI, per il parsing degli argomenti da riga di comando.

L'implementazione delle funzionalità di rete e la gestione delle connessioni è racchiusa interamente nella classe \texttt{Server.java}. Un'istanza della classe \texttt{Server} è creata al momento dell'avvio del programma. Il costruttore del server accetta come argomenti cinque parametri: indirizzo IP e porta per effettuare il bind della socket, nome e porta del Registry RMI e directory della cartella nella quale è mantenuto lo stato del sistema. Al momento dell'istanziazione, il costruttore inizializza le variabili locali della classe, crea un socket per la gestione delle connessioni e verifica se è presente su disco, nel path specificato, un backup di una precedente esecuzione da ripristinare. In caso di errore viene lanciata un'eccezione del tipo \texttt{IOException}. In caso di successo, la funzione main invoca il metodo \texttt{start()} sull'oggetto server.\newline
\begin{lstlisting}[language=Java, caption=Firma del metodo costruttore della classe \texttt{Server.java}]
public Server(String address, int channelport, String registryname, int rmiport, String workingdir)
\end{lstlisting}
Se tutto è andato a buon fine, il metodo main procede con l'esecuzione e invoca il metodo \texttt{start()} sull'oggetto appena creato. A questo punto il nuovo oggetto avvia il server RMI e sarà pronto ad accettare nuove richieste all'indirizzo IP e porta specificati dall'utente.

\subsection{Funzionalità di rete e gestione delle connessioni}

Nella tradizionale visione bloccante, proposta dalla libreria Java IO, il server sarebbe stato costituito da almeno un thread, con un oggetto della classe ServerSocket in ascolto, bloccato, per nuove connessioni, e da \emph n thread (o da una threadpool), ognuno relegato alla gestione di una singola socket, bloccato in attesa che il client invii dati da elaborare sulla connessione; questo meccanismo non è adatto per sopportare alti carichi di lavoro: il processo di creazione dei thread è molto costoso, la creazione di un thread comporta notevole overhead da parte del sistema operativo, così come le commutazioni di contesto e i meccanismi di sincronizzazione necessari per l'esecuzione del codice. Inoltre, si deve considerare che la maggior parte dei thread potrebbe rimanere bloccata in ascolto di dati da parte del client per gran parte della durata del suo ciclo di vita. Il server sviluppato con Java IO, subirebbe un degrado delle performance sotto carico.
Per questo progetto, è stato quindi deciso di implementare un server con comportamento non bloccante, utilizzando la libreria Java NIO.
\newline

L'implementazione del server attraverso NIO effettua il multiplexing delle richieste ed è basata su tre componenti fondamentali: 
\begin{itemize}
    \item un oggetto della classe \texttt{ServerSocketChannel} che rimane in ascolto delle connessioni in arrivo;
    \item un \texttt{SocketChannel} per ogni connessione attiva;
    \item un \texttt{Selector} per iterare sulle connessioni attive ed effettuare il multiplexing di queste.
\end{itemize}
Al momento della creazione del server viene istanziato un \texttt{Selector} e il \texttt{ServerSocketChannel}, tramite l'invocazione del metodo \texttt{open()}; per il corretto funzionamento in modalità non bloccante, l'oggetto \texttt{serverSocketChannel} è registrato sul selettore appena creato. In seguito all'invocazione del metodo \texttt{start()}, il server entra in un ciclo \texttt{while(true)}; ad ogni iterazione è verificata la presenza o meno di canali pronti per effettuare qualche operazione. Se il selettore non è vuoto (ovvero, restituisce un valore diverso da zero invocando su di esso il metodo \texttt{select()}), si crea un oggetto di tipo \texttt{Iterator<SelectionKey>} per iterare sul set di chiavi corrispondenti ai canali disponibili. Per ogni chiave restituita dall'iteratore, si individua il tipo di evento pronto da essere elaborato: se la chiave corrisponde ad un evento di tipo \texttt{OP\_ACCEPT}, vi è una nuova connessione in arrivo e si invoca il metodo privato \texttt{accept()}, che si occupa di creare un nuovo SocketChannel per la connessione, di registrarlo sul selettore e di allocare un buffer\footnote{Per l'allocazione dei buffer sono stati utilizzati oggetti della classe \texttt{ByteBuffer}. La dimensione è fissata di default in 8KB} per la memorizzazione dei dati; se il canale invece risulta \emph{readable}, si procede con l'handling della richiesta chiamando il metodo privato \texttt{readSocketChannel()}.

\subsubsection{Il metodo readSocketChannel}
Quando invocato, si occupa di leggere i dati presenti sul buffer associato alla chiave selezionata e di fornire una risposta appropriata al messaggio in esso contenuto. Dopo aver istanziato le variabili locali, il metodo si occupa di controllare che il canale sia effettivamente aperto e leggibile; in caso di canale non leggibile, in caso di errori, o quando un client chiude la connessione in maniera inaspettata, l'utente associato a quella particolare socket dev'essere eliminato dalla lista degli utenti online: per consentire questa operazione, il server mantiene nelle variabili locali di ogni utente un riferimento alla connessione in uso: il sistema consente che sia attiva al più un'istanza di un singolo utente durante l'esecuzione del programma.

Se il canale è leggibile, incomincia la trascrizione dei dati dal buffer in oggetti locali: il contenuto del buffer viene decodificato in stringa, e la stringa viene deserializzata in un oggetto JSON. Se l'operazione va a buon fine, ovvero, se la stringa rappresenta un oggetto JSON valido, la funzione recupera la proprietà \texttt{method} dall'oggetto e tenta di recuperare le altre proprietà richieste dal metodo per essere eseguito; a questo punto, è chiamata la funzione locale corretta che restituirà un nuovo oggetto JSON contenente i dati dell'elaborazione (eventualmente, anche un codice di errore in caso di elaborazione non andata a buon fine); al ritorno di un handler, readSocketChannel serializza l'oggetto risposta in stringa, trascrive la stringa sul buffer e scrive i dati sul SocketChannel. Infine il canale è nuovamente registrato in lettura sul selettore, per permettere al client di inviare nuovi dati.

\subsection{Strutture dati principali della classe Server}
\label{strutture_dati_server}
La classe Server, durante l'esecuzione, mantiene i dati in memoria principale attraverso mappe chiave-valore del tipo \texttt{ConcurrentHashMap<>}. La scelta di oggetti di tipo Map, invece che di oggetti di tipo List per la memorizzazione dei dati, è stata ritenuta più efficiente dal momento che la maggior parte degli accessi alle risorse sono effettuati per nome: si pensi all'operazione di recupero delle informazioni di un utente, o alle informazioni relative alla lista dei membri di un singolo progetto. Una soluzione con strutture del tipo \texttt{ArrayList<>} avrebbe probabilmente avuto problemi di performance in riferimento a questo particolare caso d'uso, specialmente con un alto numero di utenti o progetti e considerata la natura single-threaded dell'applicazione. Per ottimizzare le performance in tempo della HashMap, sarà inoltre possibile modificare in futuro il fattore di carico della struttura per evitare il numero di collisioni interne.
Dunque, il server possiede due strutture dati principali per la memorizzazione dei contenuti:
\begin{itemize}
    \item Una \texttt{ConcurrentHashMap<String, User>} per la memorizzazione degli utenti a runtime;
    \item Una \texttt{ConcurrentHashMap<String, Project>} per la memorizzazione dei progetti.
\end{itemize}
Le strutture dati sono state scelte \emph{thread-safe} per evitare problemi di sincronizzazione e consistenza dei dati in caso di accessi concorrenti da parte del thread main e dagli eventuali thread RMI: sebbene la mutua esclusione sull'esecuzione dei metodi RMI sia garantita dall'implementazione dei metodi della classe stessa (della quale si discuterà nel sottoparagrafo seguente), nulla avrebbe garantito l'accesso in mutua esclusione alle strutture dati condivise fra le classi Server e RMIServer.
\emph{Inoltre, se in un futuro si volesse espandere l'applicazione per far gestire le richieste da più thread workers, in maniera asincrona, non sarà necessario implementare ulteriori meccanismi di sincronizzazione sulle strutture dati di base del sistema, garantendo un minimo di funzionalità out-of-the-box.}

\subsection{RMI per le operazioni di Registrazione e Callback}
Come richiesto nelle specifiche dell'implementazione, le funzionalità di registrazione di nuovi utenti al servizio e callback per notifiche di login e logout verso i client, sono state implementate con il protocollo RMI. Il meccanismo delle callback RMI è stato inoltre utilizzato per comunicare al client gli estremi per unirsi alla chat di un progetto, nel momento in cui questi vengono aggiunti. Le funzionalità del server RMI sono implementate nella classe \texttt{RMIServer.java}, che a sua volta implementa l'interfaccia \texttt{RMIServerInterface.java}

La classe è istanziata all'interno del metodo \texttt{startRMI()} della classe Server, in seguito alla creazione di un nuovo oggetto, il metodo provvede anche ad effettuare il bind di un nuovo registry e al contestuale avvio del server RMI.\newline 
\begin{lstlisting}[language=Java, caption=Interfaccia \texttt{RMIServerInterface.java}]
public interface RMIServerInterface extends Remote {
    int  signUp(String Username, String password)         throws RemoteException;
    void registerForCallback(RMIClientInterface client)   throws RemoteException;
    void unregisterForCallback(RMIClientInterface client) throws RemoteException;
}
\end{lstlisting}
Il costruttore della classe \texttt{RMIServer} accetta due parametri: la HashMap degli utenti iscritti al servizio, e un'istanza della classe FileHandler, della quale si illustreranno le funzionalità in seguito, per permettere la memorizzazione dei nuovi profili utente al momento della registrazione.
Tutti i metodi sono di tipo \texttt{synchronized void}, questa sincronizzazione è necessaria, dal momento che non è possibile sapere a priori quanti e quali thread RMI eseguiranno i metodi della classe.
RMIServer possiede inoltre una struttura dati locale per mantenere in memoria i client registrati alle callback di Utenti e Chat di progetto.
L'operazione di registrazione è implementata dal metodo \texttt{signUp(String username, String password)}: quando un client invoca questo metodo, viene creata una nuovo oggetto della classe User e aggiunto alla mappa degli utenti: l'utente appena registrato potrà ora effettuare il login sul server.
Per quanto riguarda le Callback per le notifiche di eventi, il client si registra invocando il metodo \texttt{RegisterForCallback(RMIClientInterface)}, e fornisce una sua interfaccia pubblica contenente la firma dei metodi che il server potrà chiamare per notificare l'iscrizione alla chat di un nuovo progetto o il cambiamento di stato (online, offline) di un utente. 
In caso di eccezioni RMI dipendenti da disconnessioni inaspettate dei client, è individuata la connessione che ha sollevato l'eccezione, e rimosso il client associato dalla lista dei client registrati per le notifiche.

\subsection{La classe User}
Questa classe rappresenta un utente della piattaforma WORTH. Un'istanza di una classe User è creata dal server RMI al momento dell'iscrizione. Inoltre, gli oggetti di tipo User sono ripristinati dal server in caso di riavvio del sistema.\newline
Ogni oggetto della classe consta di cinque variabili di istanza: 

\begin{enumerate}
    \item Tre oggetti della classe \texttt{String} rispettivamente per username, password e \emph{salt} della password;
    \item Una variabile di tipo \texttt{boolean}, per indicare lo stato (online, offline) dell'utente;
    \item Una variabile di tipo \texttt{int} che contiene l'hash
          dell'oggetto SocketChannel
          \footnote{Il codice hash della socket è ottenuto chiamando il metodo \texttt{hashCode()} sull'oggetto SocketChannel associato.},
          in modo da poter recuperare facilmente e univocamente la connessione associata all'utente.
\end{enumerate}
Il costruttore della classe accetta esattamente tre argomenti, di cui al punto uno. Lo stato dell'utente è impostato di default con il valore \texttt{false} e il codice hash relativo alla socket associata è impostato dal server al momento del login. Tutte le variabili d'istanza di User sono accessibili mediante i metodi di default \texttt{get} (informalmente detti \emph{"getters"}), e sono modificabili a runtime mediante i metodi \texttt{set} (\emph{"setters"})

\subsubsection{Cenni sulla memorizzazione delle password}
Per quanto WORTH sia un progetto sviluppato puramente a scopo didattico, nel quale alcuni dettagli \emph{potrebbero} essere trascurati (e.g. piccoli aspetti riguardanti la sicurezza), è stato scelto, almeno limitatamente alla classe User, di adottare una strategia \emph{puramente dimostrativa} che si proponga di oscurare le password per ogni utente, in modo da non rendere accessibili dai files di backup \emph{"in chiaro"} le credenziali di accesso degli utenti.
L'hashing delle password degli utenti è delegato alla classe \texttt{PasswordHandler}. Nel momento in cui un nuovo utente si registra, viene generato automaticamente un \emph{salt}
\footnote{Il \emph{salt} è una sequenza di numeri casuali posti prima o dopo la password, per evitare attacchi di tipo dizionario} 
e l'hash della password inserita, attraverso la creazione di un oggetto del tipo \texttt{PBEKeySpec}
\footnote{La classe PBEKeySpec fa parte della libreria embedded \texttt{javax.crypto}}, 
che esegue l'hashing utilizzando l'algoritmo SHA-1; al termine del processo, l'hash e il salt sono memorizzati all'interno dell'oggetto utente con codifica Base64, in modo da rendere tutti i caratteri stampabili, nonché sul filesystem.
Il riconoscimento della password è effettuato in maniera analoga: per ogni tentativo di login è calcolato l'hash della password inserita e lo si confronta con l'hash presente sul server: se le due stringhe coincidono, la password inserita è corretta.

\subsection{La classe Project}
Analogamente alla classe User, \texttt{Project.java} rappresenta un progetto del sistema WORTH, tuttavia a differenza di \texttt{User} non si occupa solamente di memorizzare i dati relativi al progetto, ma effettua operazioni sui dati di progetto (come gestione persistenza sul disco, spostamento di card, e controlli sui vincoli imposti da specifica) su richiesta del client.
La classe Project possiede due campi \texttt{String}, per la memorizzazione del nome di progetto e per l'indirizzo della chat, e possiede quattro strutture di tipo \texttt{HashMap<String, Card>} per la memorizzazione delle Card rappresentanti i task da svolgere per portare a termine l'attività. Come già discusso in precedenza (si veda \ref{strutture_dati_server}), è stato scelto di utilizzare una mappa per la memorizzazione delle Card dal momento che l'accesso alle risorse è effettuato prevalentemente per nome. I membri di progetto sono memorizzati in una struttura \texttt{ArrayList<User>}

La classe Project possiede due costruttori: entrambi accettano due oggetti di tipo \texttt{String} per memorizzare il nome di progetto e l'indirizzo multicast relativo alla chat; i costruttori richiedono inoltre un'istanza della classe \texttt{FileHandler}, per mantenere sul filesystem le modifiche, quando avvengono. La differenza fra i due costruttori, consiste nel modo in cui essi inizializzano i membri di progetto: un costruttore, infatti, accetta un'oggetto di tipo \texttt{User}\footnote{Un nuovo progetto è inizializzato ponendo come unico membro l'utente che ha effettuato la richiesta di creazione.}, ed è utilizzato al momento della creazione di un nuovo progetto, a runtime, quando questa richiesta proviene da un client; L'altro prevede il passaggio di un riferimento ad un \texttt{ArrayList<User>}, e si utilizza al momento del rirpristino, quando è già nota, dai files di backup, la lista dei membri del progetto.
Oltre ai metodi standard \emph{getters} e \emph{setters} per il recupero dei riferimenti agli oggetti locali e la loro modifica, sono presenti alcuni metodi fondamentali per la gestione delle funzionalità della piattaforma WORTH, in particolare i metodi relativi alla gestione delle card di progetto, elencati di seguito:
\begin{itemize}
    \item \texttt{public void addCard(Card card)}: aggiunge un oggetto di tipo card al progetto, nella lista corretta. In alternativa è possibile delegare alla classe project la creazione di una nuova Card, passando al metodo il nome e la descrizione della card. In caso di card già esistente, verrà sollevata un'eccezione \texttt{CardAlreadyExistsException}. Il comportamento in caso di errore è analogo fra i due metodi.
    \item \texttt{public void moveCard(String name, String from, String to)}: si occupa di spostare una card da una lista from ad una lista to, effettuando controlli sui vincoli di movimento delle card, richiesti dalle specifiche del progetto, e controlli sull'effettiva esistenza della card. In caso di vincoli violati, sarà sollevata un'eccezione \texttt{CardMoveForbidden}; in caso di card non esistente l'eccezione sarà \texttt{CardNotFoundException}.
\end{itemize}
In caso di richiesta di eliminazione di un progetto, il server invoca il metodo \texttt{public boolean isAllDone()}, che verifica l'effettivo completamento di tutti i task di progetto, prima di procedere con l'eliminazione.
Ogni modifica alle proprietà di un progetto, inclusa la cancellazione, è salvata sul filesystem mediante l'invocazione dei metodi della classe FileHandler.


\subsection{Le classi Card e CardEvent}
Rappresentano rispettivamente una card e un evento di spostamento della card all'interno di un progetto.
La classe Card possiede le informazioni strettamente necessarie per l'identificazione di essa, ossia nome, descrizione testuale e lista nella quale si trova: sono quindi nuovamente stati implementati i metodi get e set di default per recuperare e impostare le variabili di istanza di ogni oggetto. La cronologia degli spostamenti di una card da una lista all'altra è mantenuta in una lista ordinata, in ordine crescente, per data. Ogni evento di spostamento è rappresentato da un'istanza della classe CardEvent, che mantiene fra le variabili locali un riferimento alla data dello spostamento (tipo \texttt{long}, rappresentante la timestamp dell'evento in secondi trascorsi da \texttt{Epoch}), una stringa indicante la lista di partenza, e un'altra indicante la lista di destinazione. Per garantire l'ordinamento, la classe implementa l'interfaccia Comparable, e per permettere il confronto cronologico fra due eventi, è stato implementato l'override del metodo \texttt{compareTo()} di Comparable.
In caso di ripristino da backup, la classe Card ammette accetta nel costruttore un riferimento ad un oggetto \texttt{ArrayList<CardEvent>}.


\subsection{Generazione e riuso di indirizzi multicast con MulticastBaker}
La classe MulticastBaker è responsabile della generazione degli indirizzi Multicast necessari al funzionamento della chat. La classe implementa due metodi statici, invocati dal server al momento della creazione di un nuovo progetto, o quando un nuovo progetto verrà eliminato e il relativo indirizzo chat sarà nuovamente disponibile.
Dal momento che l'ultimo byte dell'indirizzo multicast è costante e vale 224, la classe mantiene in memoria solamente la variabile intera \texttt{multicastSuffix}, rappresentante i primi 24 bit dell'indirizzo, inizialmente posta a uno. Ad ogni invocazione del metodo \texttt{getNewMulticastAddress()}, se non sono stati rilasciati indirizzi generati precedentemente, il valore della variabile è incrementato di uno. L'indirizzo creato, è memorizzato mediante un array di interi: ogni posizione rappresenta un otteto dell'indirizzo. La prima posizione dell'array è inizializzata con il valore fisso 0xE0 (224)
\footnote{Non sono calcolati gli indirizzi a scope amministrativo.}; i restanti tre byte sono invece calcolati effettuando l'operazione di \emph{shift destro} dei bit e applicando una maschera del valore 0xFF (255)\footnote{Applicata con l'operazione AND bit a bit} al risultato, per recuperare solamente i primi otto bit: il primo byte è ottenuto applicando direttamente la maschera al suffisso, i restanti due sono calcolati effettuando lo \emph{shift destro} del suffisso rispettivamente di otto e sedici bit, in seguito è applicata la maschera. L'indirizzo è restituito sotto forma di stringa del formato 224.x.x.x;
In caso di indirizzi esauriti (quando il suffisso vale 0xFFFFFF), è restituito al chiamante il valore nullo.\newline
\begin{lstlisting}[language=Java, caption=Inizializzazione del secondo byte dell'indirizzo]
    address[2] = ((multicastSuffix >> 0x8) & 0xFF); 
\end{lstlisting}

\subsection{La persistenza sul filesystem con FileHandler}
La fine del capitolo riguardante l'implementazione del server è dedicata alla persistenza dei dati e al ripristino dello stato del sistema in caso di riavvio della piattaforma.
La classe FileHandler è implementata utilizzando la libreria Java IO, che offre l'implementazione dei metodi per l'accesso al filesystem. FileHandler possiede tutti i metodi necessari per la lettura e la scrittura dei dati WORTH in memoria secondaria. Un'istanza della classe è creata al momento dell'avvio del server. Il costruttore della classe accetta un parametro, stringa, che individua la directory nella quale sarà presente la directory del sistema worth contenente i dati degli utenti e dei progetti. Al momento della chiamata, è verificata l'esistenza della sottodirectory \texttt{./worth} (che chiameremo per semplicità directory base), nel path ricevuto. Se è presente, ritorna; se non è presente tenta la creazione di tali cartelle: in caso di fallimento, è forzata l'uscita dal programma, in quanto non è possibile il funzionamento corretto del server.
I dati sono salvati su disco secondo questo schema: la directory base contiene due sottocartelle, una denominata projects, l'altra denominata users. All'interno della prima vi sono ulteriori cartelle, ognuna per ogni progetto: all'interno sarà immagazzinato un file contenente le proprietà del progetto (nome, lista dei membri) e ulteriori \emph n files, ognuno per le \emph n card associate al progetto. La cartella Users, invece conterrà un file per ogni utente registrato alla piattaforma.\newline

I file sono salvati tutti utilizzando il formato JSON. Per serializzare gli oggetti locali in stringhe JSON, è stata anche in questo caso utilizzata la libreria GSON; tuttavia, anziché utilizzare oggetti "generici" della classe JsonObject, sono stati implementati metodi custom per la serializzazione e la deserializzazione delle classi: questa scelta implementativa ha permesso un maggiore controllo sulle proprietà inserite all'interno dei files di backup, permettendo una serializzazione più concisa. I metodi per la serializzazione e la deserializzazione sono contenuti nella classe \texttt{shared.serializers.FileSerializerHelper.java}. Un riferimento ai metodi è stato poi passato ad un'istanza della classe GSON, all'interno del metodo privato \texttt{setJson()}.
\newline
\begin{lstlisting}[language=Java, caption=Esempio di serializzatore per la classe User]
public JsonSerializer<User> userJsonSerializer = (user, type, context) -> {

        JsonObject serialized = new JsonObject();
        
        serialized.addProperty("name",     user.getUsername());
        serialized.addProperty("password", user.getPassword());
        serialized.addProperty("salt",     user.getSalt());
        return serialized;
    };
\end{lstlisting}

I metodi della classe FileHandler si suddividono in metodi \emph{loader} e metodi \emph{saver}. I metodi loader sono chiamati solo all'avvio del sistema, e ricercano nei path noti i files relativi ad uno stato precedente, ritornando le strutture dati così come si trovavano al momento dell'arresto del server; in caso di errore nel ripristino viene sollevata una \texttt{IOException}. I metodi \emph{saver}, invece, sono invocati dal server ogni volta che lo stato del sistema subisce modifiche: si pensi alla creazione o eliminazione di un progetto, allo spostamento di una card o all'iscrizione di un utente. Questi metodi sono stati dichiarati utilizzando la keyword synchronized, dal momento che un'unica istanza di FileHandler è creata e condivisa dal sistema: possono essere infatti invocati sia dal thread main, sia dai thread RMI; anche in questo caso non è possibile fare assunzioni sulla gestione della concorrenza, dunque è stato necessario introdurre manualmente la sincronizzazione su accessi concorrenti all'istanza.




\newpage
\section{Implementazione del Client}
Il Client implementa le funzionalità con cui gli utenti di WORTH interagiscono col server e svolgono le proprie azioni. È stato sviluppato sia un client a riga di comando, sia un'interfaccia grafica. Per quanto riguarda l'interfaccia grafica, la maggior parte dei costrutti sono stati ereditati dal client CLI e riadattati. 

\subsection{Interfaccia a riga di comando (CLI)}
Il client a riga di comando, è stato sviluppato utilizzando Java 8. Si compone di tre classi principali: La classe Main, che si occupa dell'interazione con gli utenti, la classe Client, che implementa i metodi per gestire la connessione TCP col client, e la classe ChatHelper, che si occupa di ricevere e inviare i messaggi relativi alle chat di progetto. I riferimenti al server sono specificati dall'utente al momento dell'avvio del programma, attraverso riga di comando; se non sono specificati argomenti sono utilizzati i valori di default: in particolare, in caso di assenza di riferimenti al server, il client tenterà la connessione sull'indirizzo IP locale della macchina su cui si trova in esecuzione. In caso di connessione impossibile da stabilire, è visualizzato un messaggio di errore e l'esecuzione è terminata. Inoltre, al momento dell'avvio, è stabilita una connessione anche al registry RMI del server, per operazioni di registrazione e callback.

\subsubsection{I messaggi verso il Server}
All'inizio dell'esecuzione, sono stampati a terminale i comandi disponibili per essere selezionati. L'utente è guidato durante l'esecuzione di un comando: l'input da tastiera è stato realizzato utilizzato un \texttt{BufferedStreamReader}. Al completamento di un comando, è effettuato il parsing degli argomenti in un oggetto JsonObject: come per il server è stata utilizzata la libreria GSON. Ogni messaggio inviato dal Client, contiene il campo \texttt{method} per specificare l'operazione che si intende eseguire, e il campo \texttt{username}: questi campi sono obbligatori perché il server possa accettare la richiesta. Al termine della serializzazione in Stringa JSON, il messaggio è inviato attraverso un SocketChannel, e si rimane in attesa di una risposta dal Server: se la richiesta è andata a buon fine, viene visualizzato il contenuto richiesto, altrimenti è visualizzato un messaggio di errore con relativo codice.

\subsubsection{RMI e Callback}
Al momento dell'operazione di login, il client registra uno stub con i riferimenti agli oggetti locali del tipo \texttt{RMIClientInterface} sul server, in modo che possano essere utilizzati meccanismi di callback al verificarsi di determinati eventi: le callback RMI sono state utilizzate per mantenere aggiornata sul client la lista degli utenti iscritti al servizio, e per comunicare i riferimenti relativi alla chat di un progetto durante l'esecuzione del client; sebbene, infatti, il client recuperi la lista degli indirizzi multicast relativi alle chat dei progetti al momento del login, utilizzando le callback è possibile ricevere una notifica relativa a nuovi progetti in tempo reale, senza che l'utente debba aggiornare manualmente le liste di progetto; analogamente viene ricevuta una notifica anche al momento dell'eliminazione di un progetto, con conseguente abbandono del gruppo Multicast.\newline

\begin{lstlisting}[language=Java, caption=Interfaccia \texttt{RMIClientInterface.java}]
public interface RMIClientInterface extends Remote {
    void notifyUser(String username, Boolean status)    throws RemoteException;
    void notifyChat(String address, String projectname) throws RemoteException;
    void leaveGroup(String address, String projectname) throws RemoteException;
    String getUsername()                                throws RemoteException;
}
\end{lstlisting}

\subsubsection{Implementazione della chat con DatagramChannel}
La chat di progetto è implementata utilizzando IP Multicast: in questo modo, un singolo client può inviare un datagramma UDP ad un gruppo di client interessati, e i messaggi chat possono essere inviati direttamente da client a client, senza utilizzare un server intermedio.
Le funzionalità della chat sono state implementate nella classe \texttt{ChatHelper}. Al momento dell'istanziazione della classe, sono inizializzate le strutture dati per la memorizzazione dei riferimenti e dei messaggi ricevuti durante la sessione, ed è aperto un socket UDP per la ricezione dei pacchetti Multicast. 
Per la ricezione dei datagrammi UDP, è stato utilizzato un oggetto della classe \texttt{DatagramChannel}, in modalità non bloccante. Al momento del login, il server comunica al client una mappa chiave-valore, in formato JSON, contenente per ogni entry una coppia del tipo (nome-progetto, indirizzo-chat). Per ogni entry della mappa, il client invoca sull'oggetto ChatHelper il metodo \texttt{joinGroup}, passando come argomento una entry della mappa; a questo punto, ChatHelper invoca il metodo \texttt{join()} sul DatagramChannel locale. E' mantenuta inoltre in memoria la coppia (nome-progetto, \texttt{MembershipKey}), in modo da poter revocare la sottoscrizione ad un gruppo multicast in caso di cancellazione di un progetto. Il metodo \texttt{leaveGroup} per l'abbandono di un gruppo è invocato dal server tramite Callback RMI, a cura del metodo \texttt{Server.deleteProject()}.
Per la lettura dei dati dal canale, è utilizzato un thread che invoca periodicamente il metodo \texttt{readDatagramChannel()}, in modo da avere la lista dei messaggi per ogni progetto sempre aggiornata. Il controllo degli accessi concorrenti all'oggetto è garantito dall'utilizzo di strutture dati concorrenti; Inoltre le classi DatagramChannel e Selector, sono \emph{thread safe}, secondo quanto specificato nella documentazione ufficiale di Java.
Al momento dell'invio di un messaggio, il client chiama il metodo \texttt{sendmessage()} sull'oggetto chatHelper. Il DatagramChannel si occuperà di inviare i messaggi all'indirizzo specificato.

\subsection{Interfaccia grafica (GUI)}
Per questo progetto, è stato sviluppato anche un client GUI, in modo da rendere più gradevole e intuitivo l'utilizzo della piattaforma. L'interfaccia grafica è stata sviluppata utilizzando il framework JavaFX, supportato da Java 11. Gran parte del \emph{backend} è stato ereditato dal codice sorgente del client CLI, tuttavia sono state eliminate le parti relative alla gestione I/O testuale, in particolare gli oggetti InputStream per la lettura dell'input da tastiera.
Le finestre e il layout della GUI sono descritti in files FXML, per semplicità di sviluppo. Ad ogni è stato associato un Controller per gestire le operazioni dell'utente: i metodi della classe Client sono ora invocati attraverso eventi sulla finestra sulla finestra o tramite eventi rilevati su oggetti Button. Il client GUI possiede anche classi "lite" delle componenti della piattaforma WORTH, istanziate al momento del recupero di informazioni dal server, in modo da avere strutture dati più robuste rispetto al solo JSON utilizzato dalla CLI.

\subsubsection{Implementazione della chat grafica}
Sostanziale è la differenza nel modo in cui gli utenti possono accedere alla chat, rispetto al client testuale. Per migliorare l'esperienza d'uso, la TextArea riguardante la chat di progetto è ricaricata al momento della selezione di un progetto dalla lista, e viene aggiornata attraverso un meccanismo di callback direttamente dal thread ChatListener, alla ricezione di un nuovo datagramma.

 Al momento della creazione della finestra principale, in seguito al login, è creato anche un oggetto della classe ChatCallback, implementante l'interfaccia ChatCallbackHandler, nota a ChatHelper, e si occupa di aggiornare le strutture dati locali del client che persistono i messaggi. Un riferimento a ChatCallback è impostato sull'istanza ChatHandler: a questo punto, alla ricezione di un nuovo messaggio, ChatHandler invocherà il metodo \texttt{handleMessage()} sul proprio riferimento a ChatCallback: è chiamato dunque il metodo \texttt{notifyMessage()} del Controller JavaFX \footnote{Il controller della main window è implementato dalla classe \texttt{WorthController.java}.}associato alla finestra principale: a questo punto, il messaggio ricevuto è salvato in una lista contenuta all'interno di un'istanza di \texttt{ConcurrentHashMap}, in modo da essere visualizzato sulla TextArea alla selezione del progetto corrispondente. Se in quel momento è selezionato il progetto relativo al messaggio ricevuto, la TextArea è aggiornata, e il messaggio visualizzato in tempo reale.\newline
 
\begin{lstlisting}[language=Java, caption=Il metodo \texttt{notifyMessage()}]
public void notifyMessage(String projectname, String message){
    if(!messages.containsKey(projectname)) 
        messages.putIfAbsent(projectname, new ArrayList<>());
        
    messages.get(projectname).add(message);
    if (projectsTable
        .getSelectionModel()
        .getSelectedItem()
        .getName()
        .equals(projectname)){
        chatArea.appendText(message + "\n");
    }
}
\end{lstlisting}

\newpage
\section{Quick start guide}
\subsection{Istruzioni per la compilazione e l'esecuzione}
\subsection{Utilizzo dell'interfaccia a riga di comando}
\subsection{Utilizzo della GUI}


\end{document}
